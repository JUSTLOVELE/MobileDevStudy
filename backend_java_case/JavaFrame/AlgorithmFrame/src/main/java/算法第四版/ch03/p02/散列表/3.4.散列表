如果所有的键都是小整数,我们可以用一个数组来实现无序的符号表,将键作为数组的索引而数组中键i处存储的就是它对应的值,这样我们就可以快速访问任意键的值
使用散列的查找算法分为两步:
   1.使用散列函数将被查找的键转化为数组的一个索引,理想情况下,不同的键都能转化为不同的索引值
   2.处理碰撞冲突的过程
散列表是算法在时间和空间上做出权衡的经典例子,如果没有内存限制,我们可以直接将键作为数组的索引,那么所有查找操作只需要访问内存一次即可完成,
但这种理想的情况不会经常出现,因为当键很多时需要的内存太大,另一方面如果没有时间限制,我们可以使用无序数组并进行顺序查找,这样就只需要很少的内存,
而散列表则使用了适度的空间和时间并在两个极端之间找到一种平衡
     散列函数: 散列函数的计算过程会将键转化为数组的索引,如果我们有一个能够保存M个键值对的数组,那么我们就需要一个能够将任意键转化为该数组范围内的索引([0,M-1])
的散列函数,我们要找的散列函数应该易于计算并且能够均匀分布所有的键,即对于任意键,0-M-1之间的每个整数都有相等的可能性与之对应
  散列函数和键的类型有关,严格的说,对于每种类型的键我们都需要一个与之对应的散列函数,如果键是一个数,比如社保卡号,我们就可以直接使用这个数,如果键是一个字符串
就需要将这个字符串转化为一个数
  正整数: 将整数散列最常用的方法的除留余数法:选择大小为素数M的数组,对于任意正整数k,计算k除以M的余数
  浮点数: 如果键是0-1之间的实数,我们可以将它乘以M并四舍五入得到一个0-M-1之间的索引值(将键表示为二进制然后再使用除留余数法)