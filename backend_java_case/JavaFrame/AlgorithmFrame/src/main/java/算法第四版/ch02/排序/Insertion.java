package 算法第四版.ch02.排序;

/**
 * 2.插入排序
 * 通常人们整理桥牌的方法是一张一张的来,将每一张牌插入到其他已经有序的牌中的适当位置,
 * 在计算机的实现中,为了给要插入的元素腾出空间,我们需要将其余所有元素在插入之前都向右移动一位,这叫做插入排序
 *  与选择排序一样,当前索引左边的所有元素都是有序的,但它们的最终位置还不确定,为了给更小的元素腾出空间,它们可能会被移动
 * 但是当索引到达数组的右端时,数组排序就完成了
 *  和选择排序不同的是,插入排序所需的时间取决于输入中元素的初始顺序
 *  
 * 命题B： 对于随机排列的长度为N且主键不重复的数组,平均情况插入排序需要~N*N/4次比较以及~N*N/4次交换,
 *最坏情况下需要~N*N/2次比较和~N*N/2次交换,最好情况下需要N-1次比较和0次交换
 *
 *  插入排序对于实际应用中常见的某些类型的非随机数组很有效,例如用插入排序对一个有序数组进行排序,插入排序
 *能够立即发现每个元素都已经在合适的位置上,它的运行时间也是线性的(对于这种数组,选择排序的运行时间是平方级别的)
 *
 * 命题C:插入排序需要的交换操作和数组中倒置的数量相同,需要的比较次数大于等于倒置的数量,小于等于倒置的数量加上数组的大小再-1
 *
 * @author yangzuliang
 *
 */
public class Insertion extends Example{
	
	/**
	 * 要大幅提高插入排序的速度并不难,只需要在内循环中较大的元素都向右移动
	 * 而不总是交换两个元素(这样访问次数就能减半)
	 * @param a
	 */
    public static void sort(Comparable[] a){
    	
		int N = a.length;
		for(int i=1; i<N; i++){
			for(int j=i; j>0 && less(a[j], a[j-1]); j--){
				exch(a, j, j-1);
			}
		}
	}
}
