package 算法第四版.ch02.排序;

/**
 * 4.希尔排序
 *   基于插入排序的快速的排序算法,对于大规模乱序数组插入排序很慢,因为它只会交换相邻的元素,因此元素只能一点一点的从数组的一端移动到另一端
 *例如:如果主键最小的元素正好在数组的尽头,要将它挪到正确的位置就需要N-1次移动,希尔排序为了加快速度简单的改进了插入排序,交换不相邻的元素
 *以对数组的局部进行排序,并最终用插入排序将局部有序的数组排序
 *   希尔排序的思想是使数组中任意间隔为h的元素都是有序的,这样的数组被称为h有序数组,换句话说,一个h有序数组就是h个互相独立的有序数组编织
 *在一起组成的一个数组,在进行排序时,如果h很大,我们就能将元素移动到很远的地方
 *   实现希尔排序的一种方法是对于每个h,用插入排序将h个子数组独立的排序,但因为子数组是相互独立的,一个更简单的方法是在h个子数组中将每个元素交换
 *到比它大的元素之前去(将比它大的元素向右移动一格),只需要在插入排序的代码中移动元素的距离由1改为h即可,这样,希尔排序的实现就转化为了一个类似于
 *插入排序但使用不同增量的过程
 *   希尔排序更高效的原因是它权衡了子数组规模和有序性
 *   性质E：
 *     使用递增序列1,4,13,4,121,364...的希尔排序所需的比较次数不会超出N的若干倍乘以递增序列的长度
 *   优点: 代码量小,不需要使用额外的内存空间
 *   
 *   对于中等大小的数组它的运行时间是可以接受的,它的代码量很少,且不需要使用额外的内存空间,但除了对于很大的N,他们可能只会比希尔排序快两倍,而且更
 *复杂,如果你需要解决一个排序问题而又没有系统排序函数可用,可以先用希尔排序,然后再考虑是否值得将它替换为更加复杂的排序算法
 * @author yangzuliang
 *
 */
public class Shell extends Example{

	public static void sort(Comparable[] a){
		
		int N = a.length;
		int h = 1;
		
		while(h < N/3){
			h = 3*h + 1;
		}
		
		while(h >= 1){
			//将数组变为有序
			for(int i=h; i<N; i++){
				//将a[i]插入到a[i-h],a[i-2*h], a[i-3*h]...之中
				for(int j=i; j>=h && less(a[j], a[j-h]); j-=h){
					exch(a, j, j-h);
				}
			}
			
			h = h/3;
		}
	}
	
	public static void main(String[] args) {
		
		Integer[] a = new Integer[100];
		int j=0;
		for(int i=a.length-1; i>=0; i--){
			a[j] = i;
			j++;
		}
		sort(a);
		for(int b : a){
			System.out.println(b);
		}
	}
}
