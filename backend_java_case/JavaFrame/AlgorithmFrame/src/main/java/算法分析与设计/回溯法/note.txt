    回溯法有通用解题法之称,它在问题的解空间树中,按深度优先策略,从根结点出发搜索解空间树,算法搜索至解空间树的任意结点时,
先判断该结点是否包含问题的解,若肯定不包含,则跳过对以该结点为根的子树的搜索,逐层向其祖先结点回溯,否则,进入该子树,继续按深度优先搜索策略搜索
    回溯法求问题的所有解时,要回溯到根,且根节点的所有子树都被搜索遍才结束,在它求问题的一个解时,只要搜索到问题的一个解救结束,这种以深度优先方式
系统搜索问题解的算法称为回溯法,它适用于求解组合数较大的问题

  解空间:进行穷举的搜索空间
  为了用回溯法求解一个具有n个输入的问题,一般情况下将其可能表示为满足某个约束条件的等长向量X=(x1,x2,...,xn),其中xi(1<=i<=n)的取值
范围是某个有限集合Si={ai1,ai2,...airi},所有可能的解向量构成了问题的解空间
  问题的解空间一般用解空间树的方式组织,树的根节点位于第一层,表示搜索的初始状态,第二层的节点表示对解向量的第一个分量做出选择后到达的状态,第一层
到第二层的边上标出对第一个分量选择的结果,以此类推,从数的根节点到叶子节点的路径就构成了解空间的一个可能解

      回溯法从根节点出发,按照深度优先策略遍历解空间树,搜索满足约束条件的解,在搜索至树中任一节点时,先判断该节点对应的部分解是否满足约束条件,或者是否
 超出目标函数的下届,也就是判断该节点是否包含问题的解,如果肯定不包含,则跳过对以该节点为根的子树的搜索,即所谓剪枝,否则进入以该节点为根的子树,继续
 按照深度优先策略搜索
  回溯法的搜索过程设计的节点(称为搜索空间)只是整个解空间树的一部分,在搜索过程中,通常采用两种策略避免无效搜索:
  1.用约束条件剪去得不到可行解的子树
  2.用目标函数剪去得不到最优解的子树
这两类函数统称为剪枝函数,注意:解空间树是虚拟的,不需要在算法运行时构造一个真正的树,只需要存储从根节点到当前节点的路径

递归框架:
	public void backtrack(int t){
		if(t>n) {
			output(x)
		}else{
			for(int i=f(n,t); i<=g(n,t);i++){
			    x[t]=h(i);
			    if(constraint(t)&&bound(t)){
			       backtrack(t+1);
			    }
			}
		}
	}
1.当所给问题是从n个元素的集合S中找出S满足某种性质的子集时，相应的解空间称为子集树。
例如：n个物品的0-1背包问题所相应的解空间是一棵子集树，这类子集树通常有2^n个叶结点，其结点总数为(2^(n+1))-1。
遍历子集树的算法通常需奥秘加(2^n)计算时间。回溯法搜索子集树的算法一般可以描述如下：
void backtrack(int t) {
if (t > n) 
 output(x);
else
 for (int i = 0; i <= 1; i++) {
  x[t] = i;
  if (constraint(t) && bound(t))
   backtrack(t + 1);
 }
}

2.当所给问题的确定n个元素满足某种性质的排列时，相应的解空间树称为排列树。排列树通常有n!个叶结点。
因此遍历排列树需要奥秘加(n!)计算时间。旅行售货员问题的解空间是一棵排列树。回溯法搜索排列树的算法一般可以描述如下：
void backtrack(int t) {
if (t > n) 
 output(x);
else
 for (int i = t; i < n; i++) {
  swap(x[t], x[i]);
  if (constraint(t) && bound(t))
   backtrack(t + 1);
  swap(x[t], x[i]);
 }
}
	
自我总结:
 排列树:一定存在一个你所需要的正确的解的顺序,你只要根据这个顺序做处理即可
 子集树:一般分为 要和不要的两个步骤	
