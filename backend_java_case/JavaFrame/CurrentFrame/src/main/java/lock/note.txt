LockCase01:lock.lock()
LockCase03:使用Condition实现等待/通知
LockCase04:
LockCase05:一对一交替打印
LockCase06:公平锁,非公平锁
LockCase11: ReentrantReadWriteLock读读共享
LockCase12: ReentrantReadWriteLock读写互斥
LockCase13: ReentrantReadWriteLock写读互斥



锁LOCK分为公平锁和非公平锁,公平锁表示线程获取锁的顺序是按照线程枷锁的顺序来分配的(FIFO),非公平锁就是一种获取锁的抢占机制,是随机获得锁的
getHoldCount():查询当前线程保持此锁定的个数,也就是调用lock()的次数
getQueueLength():返回正等待获取此锁定的线程估计数
getWaitQueueLength(Condition condition):返回等待次锁定的相关的给定条件Condition的线程估计数
hasQueuedThread(Thread thread):查询指定的线程是否正在等待获取此锁定
hasQueuedThreads():是否有线程正在等待获取此锁定
hasWaiters():查询是否有线程正在等待与此锁定有关的condition条件
isFair():判断是不是公平锁
isHeldByCurrentThread():查询当前线程是否保持此锁定
isLocked():查询此锁定是否由任意线程保持
lockInterruptibly():当前线程未被中断,则获取锁定,如果已经被中断则出现异常
tryLock():仅在调用时锁定未被另一个线程保持的情况下,才获取锁定
tryLock(long timeout, TimeUnit unit):如果锁定在给定等待时间内没有另一个线程保持,且当前线程未被中断,则获取该锁定
